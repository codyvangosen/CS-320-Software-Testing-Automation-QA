# CS-320-Software-Testing-Automation-QA
This is a repository of my project files and final submission for my final portfolio for the CS-320 Class at SNHU.

How can I ensure that my code, program, or software is functional and secure?

Code functionality and security can be ensured through robust rounds of testing including unit tests, integration tests, and system tests to verify that each individual component as well as the system as a whole are functioning as expected. Implementation of open-source tools for continuous integration and continuous deployment (CI/CD) pipelines facilitates automation of testing techniques. Following industry standard encryption standards such as AES or SHA help incorporate powerful encryption methodologies. This when coupled with incorporating secure development practices throughout product development can mitigate vulnerabilities and lower overhead costs related to security or breaches/attacks in the future.

How do I interpret user needs and incorporate them into a program?

Clear communication with stakeholders is essential in properly interpreting user needs. This allows for common understanding of their goals and expectations to be gained. Employing techniques such as requirement gathering, creation of user stories, and implementing feedback loops allow for further refinement of these goals. Breaking requirements down into bite-sized individual features facilitates easier design implementation of such solutions. Implementing regular user feedback is crucial for this refinement process.

How do I approach designing software?

Beginning with a clear understanding of the specific problem a piece of software is meant to solve is crucial for a solid developmental foundation. Incorporating principles of modularity, scalability, and maintainability provide a stable framework to guide the entirety of the design process. An iterative approach allows for a basic program structure to be drafted, then refined based upon testing outcomes and incorporation of feedback. Careful planning of architecture when coupled with selection of the proper frameworks, languages, or libraries facilitates ease of implementation throughout the design process. In addition, focusing upon scalability, evolution, and prioritizing security and performance allow for issues to be discovered much earlier in the design process, rather than accruing a large technical debt.
